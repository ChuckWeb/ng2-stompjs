{"version":3,"sources":["../../src/stomp.service.ts"],"names":[],"mappings":"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","file":"stomp.service.js","sourceRoot":"","sourcesContent":["import { Injectable } from '@angular/core';\n\nimport {Observable, Observer, Subscription} from 'rxjs/Rx';\nimport { BehaviorSubject } from 'rxjs/BehaviorSubject';\n\nimport { StompConfig } from './stomp.config';\n\nimport * as Stomp from '@stomp/stompjs';\nimport { StompSubscription } from '@stomp/stompjs';\nimport {StompConfigService} from './stomp-config.service';\nimport {StompHeaders} from './stomp-headers';\n\n/**\n * Possible states for the STOMP service\n */\nexport enum StompState {\n  CLOSED,\n  TRYING,\n  CONNECTED,\n  DISCONNECTING\n}\n\n/**\n * Angular2 STOMP Service using @stomp/stomp.js\n *\n * @description This service handles subscribing to a\n * message queue using the stomp.js library, and returns\n * values via the ES6 Observable specification for\n * asynchronous value streaming by wiring the STOMP\n * messages into an observable.\n */\n\nexport class StompService {\n\n  /**\n   * State of the STOMPService\n   *\n   * It is a BehaviorSubject and will emit current status immediately. This will typically get\n   * used to show current status to the end user.\n   */\n  public state: BehaviorSubject<StompState>;\n\n  /**\n   * Will trigger when connection is established. Use this to carry out initialization.\n   * It will trigger every time a (re)connection occurs. If it is already connected\n   * it will trigger immediately. You can safely ignore the value, as it will always be\n   * StompState.CONNECTED\n   */\n  public connectObservable: Observable<StompState>;\n\n  /**\n   * Internal array to hold locallly queued messages when STOMP broker is not connected.\n   */\n  protected queuedMessages: {queueName: string, message: string, headers: StompHeaders}[]= [];\n\n  /**\n   * Configuration\n   */\n  protected config: StompConfig;\n\n  /**\n   * STOMP Client from @stomp/stomp.js\n   */\n  protected client: Stomp.Client;\n\n  /**\n   * Constructor\n   *\n   * See README and samples for configuration examples\n   */\n  public constructor(protected _configService: StompConfigService) {\n    this.state = new BehaviorSubject<StompState>(StompState.CLOSED);\n\n    this.connectObservable = this.state\n      .filter((currentState: number) => {\n        return currentState === StompState.CONNECTED;\n      });\n\n    // Setup sending queuedMessages\n    this.connectObservable.subscribe(() => {\n      this.sendQueuedMessages();\n    });\n\n    // Get configuration from config service...\n    this._configService.get().subscribe(\n      (config: StompConfig) => {\n        // ... then pass it to (and connect) STOMP:\n        this.configure(config);\n        this.try_connect();\n      }\n    );\n  }\n\n  /** Set up configuration */\n  protected configure(config: StompConfig): void {\n\n    this.config = config;\n\n    // Attempt connection, passing in a callback\n    this.client = Stomp.client(this.config.url);\n\n    // Configure client heart-beating\n    this.client.heartbeat.incoming = this.config.heartbeat_in;\n    this.client.heartbeat.outgoing = this.config.heartbeat_out;\n\n    // Auto reconnect\n    this.client.reconnect_delay = this.config.reconnect_delay;\n\n    // Set function to debug print messages\n    this.client.debug = this.config.debug || this.config.debug == null ? this.debug : () => {};\n  }\n\n\n  /**\n   * Perform connection to STOMP broker\n   */\n  protected try_connect(): void {\n\n    // Attempt connection, passing in a callback\n    this.client.connect(\n      this.config.headers,\n      this.on_connect,\n      this.on_error\n    );\n\n    this.debug('Connecting...');\n    this.state.next(StompState.TRYING);\n  }\n\n\n  /**\n   * Disconnect the connection to the STOMP broker and clean up,\n   * not sure how this method will get called, if ever.\n   * Call this method only if you know what you are doing.\n   */\n  public disconnect(): void {\n\n    // Disconnect if connected. Callback will set CLOSED state\n    if (this.client && this.client.connected) {\n      // Notify observers that we are disconnecting!\n      this.state.next(StompState.DISCONNECTING);\n\n      this.client.disconnect(\n        () => this.state.next(StompState.CLOSED)\n      );\n    }\n  }\n\n  /**\n   * The current connection status with the STOMP broker\n   * @returns {boolean}\n   */\n  public connected(): boolean {\n    return this.state.getValue() === StompState.CONNECTED;\n  }\n\n  /**\n   * Send a message to a named destination. The message must be string.\n   *\n   * The message will get locally queued if the STOMP broker is not connected. Attempt\n   * will be made to publish queued messages as soon as the broker gets connected.\n   *\n   * @param queueName\n   * @param message\n   * @param headers\n   */\n  public publish(queueName: string, message: string, headers: StompHeaders = {}): void {\n    if (this.connected()) {\n      this.client.send(queueName, headers, message);\n    } else {\n      this.debug(`Not connected, queueing ${message}`);\n      this.queuedMessages.push({queueName: <string>queueName, message: <string>message, headers});\n    }\n  }\n\n  /** Send queued messages */\n  protected sendQueuedMessages(): void {\n    const queuedMessages = this.queuedMessages;\n    this.queuedMessages = [];\n\n    this.debug(`Will try sending queued messages ${queuedMessages}`);\n\n    for (const queuedMessage of queuedMessages) {\n      this.debug(`Attempting to send ${queuedMessage}`);\n      this.publish(queuedMessage.queueName, queuedMessage.message, {});\n    }\n  }\n\n  /**\n   * Subscribe to server message queues\n   *\n   * This method can safely be called even when STOMP broker is not connected. Further\n   * if the underlying STOMP connection drops and reconnects, it will resubscribe transparently.\n   *\n   * If a header field 'ack' is not explicitly passed, 'ack' will be set to 'auto'. If you\n   * do not understand what it means, please leave it as is.\n   *\n   * Please note, however, while working with temporary queues, where the subscription request\n   * creates the\n   * underlying queue, during reconnect it might miss messages. This issue is not specific\n   * to this library but the way STOMP brokers are designed to work.\n   *\n   * @param queueName\n   * @param headers\n   * @returns {Observable<Stomp.Message>}\n   */\n  public subscribe(queueName: string, headers: StompHeaders = {}): Observable<Stomp.Message> {\n\n    /* Well the logic is complicated but works beautifully. RxJS is indeed wonderful.\n     *\n     * We need to activate the underlying subscription immediately if Stomp is connected. If not it should\n     * subscribe when it gets next connected. Further it should re establish the subscription whenever Stomp\n     * successfully reconnects.\n     *\n     * Actual implementation is simple, we filter the BehaviourSubject 'state' so that we can trigger whenever Stomp is\n     * connected. Since 'state' is a BehaviourSubject, if Stomp is already connected, it will immediately trigger.\n     *\n     * The observable that we return to caller remains same across all reconnects, so no special handling needed at\n     * the message subscriber.\n     */\n    this.debug(`Request to subscribe ${queueName}`);\n\n    // By default auto acknowledgement of messages\n    if (!headers['ack']) {\n      headers['ack'] = 'auto';\n    }\n\n    const coldObservable = Observable.create(\n      (messages: Observer<Stomp.Message>) => {\n        /*\n         * These variables will be used as part of the closure and work their magic during unsubscribe\n         */\n        let stompSubscription: StompSubscription;\n\n        let stompConnectedSubscription: Subscription;\n\n        stompConnectedSubscription = this.connectObservable\n          .subscribe(() => {\n            this.debug(`Will subscribe to ${queueName}`);\n            stompSubscription = this.client.subscribe(queueName, (message: Stomp.Message) => {\n                messages.next(message);\n              },\n              headers);\n          });\n\n        return () => { /* cleanup function, will be called when no subscribers are left */\n          this.debug(`Stop watching connection state (for ${queueName})`);\n          stompConnectedSubscription.unsubscribe();\n\n          if (this.state.getValue() === StompState.CONNECTED) {\n            this.debug(`Will unsubscribe from ${queueName} at Stomp`);\n            stompSubscription.unsubscribe();\n          } else {\n            this.debug(`Stomp not connected, no need to unsubscribe from ${queueName} at Stomp`);\n          }\n        };\n      });\n\n    /**\n     * Important - convert it to hot Observable - otherwise, if the user code subscribes\n     * to this observable twice, it will subscribe twice to Stomp broker. (This was happening in the current example).\n     * A long but good explanatory article at https://medium.com/@benlesh/hot-vs-cold-observables-f8094ed53339\n     */\n    return coldObservable.share();\n  }\n\n\n  /**\n   * Callback Functions\n   *\n   * Note the method signature: () => preserves lexical scope\n   * if we need to use this.x inside the function\n   */\n  protected debug = (args: any): void => {\n      console.log(new Date(), args);\n  }\n\n  /** Callback run on successfully connecting to server */\n  protected on_connect = () => {\n\n    this.debug('Connected');\n\n    // Indicate our connected state to observers\n    this.state.next(StompState.CONNECTED);\n  }\n\n  /** Handle errors from stomp.js */\n  protected on_error = (error: string | Stomp.Message) => {\n\n    if (typeof error === 'object') {\n      error = (<Stomp.Message>error).body;\n    }\n\n    console.error(`Error: ${error}`);\n\n    // Check for dropped connection and try reconnecting\n    if (!this.client.connected) {\n      // Reset state indicator\n      this.state.next(StompState.CLOSED);\n    }\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/** @nocollapse */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: StompConfigService, },\n];\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}