{"version":3,"file":"ng2-stompjs.umd.min.js","sources":["~/@stomp/ng2-stompjs/src/stomp-state.ts","~/@stomp/ng2-stompjs/src/stomp-r.service.ts","~/@stomp/ng2-stompjs/src/stomp.config.ts","~/@stomp/ng2-stompjs/src/stomp.service.ts"],"sourcesContent":["\nexport type StompState = number;\nexport let StompState: any = {};\nStompState.CLOSED = 0;\nStompState.TRYING = 1;\nStompState.CONNECTED = 2;\nStompState.DISCONNECTING = 3;\nStompState[StompState.CLOSED] = \"CLOSED\";\nStompState[StompState.TRYING] = \"TRYING\";\nStompState[StompState.CONNECTED] = \"CONNECTED\";\nStompState[StompState.DISCONNECTING] = \"DISCONNECTING\";\n\n","import { Injectable } from '@angular/core';\n\nimport { BehaviorSubject } from 'rxjs/BehaviorSubject';\nimport { Observable } from 'rxjs/Observable';\nimport { Observer } from 'rxjs/Observer';\nimport { Subject } from 'rxjs/Subject';\nimport { Subscription } from 'rxjs/Subscription';\nimport'rxjs/add/operator/filter';\nimport'rxjs/add/operator/share';\n\nimport { StompConfig } from './stomp.config';\n\nimport * as Stomp from '@stomp/stompjs/index';\nimport { StompSubscription } from '@stomp/stompjs/index';\nimport { StompHeaders } from './stomp-headers';\nimport { StompState } from './stomp-state';\n/**\n * Angular2 STOMP Raw Service using \\@stomp/stomp.js\n * \n * \\@description This service handles subscribing to a\n * message queue using the stomp.js library, and returns\n * values via the ES6 Observable specification for\n * asynchronous value streaming by wiring the STOMP\n * messages into an observable.\n * \n * If you will like to pass the configuration as a dependency,\n * please use StompService class.\n */\nexport class StompRService {\n/**\n * State of the STOMPService\n * \n * It is a BehaviorSubject and will emit current status immediately. This will typically get\n * used to show current status to the end user.\n */\npublic state: BehaviorSubject<StompState>;\n/**\n * Will trigger when connection is established. Use this to carry out initialization.\n * It will trigger every time a (re)connection occurs. If it is already connected\n * it will trigger immediately. You can safely ignore the value, as it will always be\n * StompState.CONNECTED\n */\npublic connectObservable: Observable<StompState>;\n/**\n * Will trigger when an error occurs. This Subject can be used to handle errors from\n * the stomp broker.\n */\npublic errorSubject: Subject<string | Stomp.Message>;\n/**\n * Internal array to hold locally queued messages when STOMP broker is not connected.\n */\nprotected queuedMessages: {queueName: string, message: string, headers: StompHeaders}[]= [];\n/**\n * Configuration\n */\nprivate _config: StompConfig;\n/**\n * STOMP Client from \\@stomp/stomp.js\n */\nprotected client: Stomp.Client;\n/**\n * Constructor\n * \n * See README and samples for configuration examples\n */\npublic constructor() {\n    this.state = new BehaviorSubject<StompState>(StompState.CLOSED);\n\n    this.connectObservable = this.state\n      .filter((currentState: number) => {\n        return currentState === StompState.CONNECTED;\n      });\n\n    // Setup sending queuedMessages\n    this.connectObservable.subscribe(() => {\n      this.sendQueuedMessages();\n    });\n\n    this.errorSubject = new Subject();\n  }\n/**\n * Set configuration\n * @param {?} value\n * @return {?}\n */\nset config(value: StompConfig) {\n    this._config = value;\n  }\n/**\n * Initialize STOMP Client\n * @return {?}\n */\nprotected initStompClient(): void {\n    // disconnect if connected\n    this.disconnect();\n\n    // url takes precedence over socketFn\n    if (typeof(this._config.url) === 'string') {\n      this.client = Stomp.client(this._config.url);\n    } else {\n      this.client = Stomp.over(this._config.url);\n    }\n\n    // Configure client heart-beating\n    this.client.heartbeat.incoming = this._config.heartbeat_in;\n    this.client.heartbeat.outgoing = this._config.heartbeat_out;\n\n    // Auto reconnect\n    this.client.reconnect_delay = this._config.reconnect_delay;\n\n    if (!this._config.debug) {\n      this.debug = function() {};\n    }\n    // Set function to debug print messages\n    this.client.debug = this.debug;\n  }\n/**\n * Perform connection to STOMP broker\n * @return {?}\n */\npublic initAndConnect(): void {\n    this.initStompClient();\n\n    if (!this._config.headers) {\n      this._config.headers = {};\n    }\n\n    // Attempt connection, passing in a callback\n    this.client.connect(\n      this._config.headers,\n      this.on_connect,\n      this.on_error\n    );\n\n    this.debug('Connecting...');\n    this.state.next(StompState.TRYING);\n  }\n/**\n * Disconnect the connection to the STOMP broker and clean up,\n * not sure how this method will get called, if ever.\n * Call this method only if you know what you are doing.\n * @return {?}\n */\npublic disconnect(): void {\n\n    // Disconnect if connected. Callback will set CLOSED state\n    if (this.client && this.client.connected) {\n      // Notify observers that we are disconnecting!\n      this.state.next(StompState.DISCONNECTING);\n\n      this.client.disconnect(\n        () => this.state.next(StompState.CLOSED)\n      );\n    }\n  }\n/**\n * The current connection status with the STOMP broker\n * @return {?}\n */\npublic connected(): boolean {\n    return this.state.getValue() === StompState.CONNECTED;\n  }\n/**\n * Send a message to a named destination. The message must be string.\n * \n * The message will get locally queued if the STOMP broker is not connected. Attempt\n * will be made to publish queued messages as soon as the broker gets connected.\n * \n * @param {?} queueName\n * @param {?} message\n * @param {?=} headers\n * @return {?}\n */\npublic publish(queueName: string, message: string, headers: StompHeaders = {}): void {\n    if (this.connected()) {\n      this.client.send(queueName, headers, message);\n    } else {\n      this.debug(`Not connected, queueing ${message}`);\n      this.queuedMessages.push({queueName: /** @type {?} */(( <string>queueName)), message: /** @type {?} */(( <string>message)), headers: headers});\n    }\n  }\n/**\n * Send queued messages\n * @return {?}\n */\nprotected sendQueuedMessages(): void {\n    const /** @type {?} */ queuedMessages = this.queuedMessages;\n    this.queuedMessages = [];\n\n    this.debug(`Will try sending queued messages ${queuedMessages}`);\n\n    for (const /** @type {?} */ queuedMessage of queuedMessages) {\n      this.debug(`Attempting to send ${queuedMessage}`);\n      this.publish(queuedMessage.queueName, queuedMessage.message, queuedMessage.headers);\n    }\n  }\n/**\n * Subscribe to server message queues\n * \n * This method can safely be called even when STOMP broker is not connected. Further\n * if the underlying STOMP connection drops and reconnects, it will resubscribe transparently.\n * \n * If a header field 'ack' is not explicitly passed, 'ack' will be set to 'auto'. If you\n * do not understand what it means, please leave it as is.\n * \n * Please note, however, while working with temporary queues, where the subscription request\n * creates the\n * underlying queue, during reconnect it might miss messages. This issue is not specific\n * to this library but the way STOMP brokers are designed to work.\n * \n * @param {?} queueName\n * @param {?=} headers\n * @return {?}\n */\npublic subscribe(queueName: string, headers: StompHeaders = {}): Observable<Stomp.Message> {\n\n    /* Well the logic is complicated but works beautifully. RxJS is indeed wonderful.\n     *\n     * We need to activate the underlying subscription immediately if Stomp is connected. If not it should\n     * subscribe when it gets next connected. Further it should re establish the subscription whenever Stomp\n     * successfully reconnects.\n     *\n     * Actual implementation is simple, we filter the BehaviourSubject 'state' so that we can trigger whenever Stomp is\n     * connected. Since 'state' is a BehaviourSubject, if Stomp is already connected, it will immediately trigger.\n     *\n     * The observable that we return to caller remains same across all reconnects, so no special handling needed at\n     * the message subscriber.\n     */\n    this.debug(`Request to subscribe ${queueName}`);\n\n    // By default auto acknowledgement of messages\n    if (!headers['ack']) {\n      headers['ack'] = 'auto';\n    }\n\n    const /** @type {?} */ coldObservable = Observable.create(\n      (messages: Observer<Stomp.Message>) => {\n        /*\n         * These variables will be used as part of the closure and work their magic during unsubscribe\n         */\n        let /** @type {?} */ stompSubscription: StompSubscription;\n\n        let /** @type {?} */ stompConnectedSubscription: Subscription;\n\n        stompConnectedSubscription = this.connectObservable\n          .subscribe(() => {\n            this.debug(`Will subscribe to ${queueName}`);\n            stompSubscription = this.client.subscribe(queueName, (message: Stomp.Message) => {\n                messages.next(message);\n              },\n              headers);\n          });\n\n        return () => { /* cleanup function, will be called when no subscribers are left */\n          this.debug(`Stop watching connection state (for ${queueName})`);\n          stompConnectedSubscription.unsubscribe();\n\n          if (this.state.getValue() === StompState.CONNECTED) {\n            this.debug(`Will unsubscribe from ${queueName} at Stomp`);\n            stompSubscription.unsubscribe();\n          } else {\n            this.debug(`Stomp not connected, no need to unsubscribe from ${queueName} at Stomp`);\n          }\n        };\n      });\n\n    /**\n     * Important - convert it to hot Observable - otherwise, if the user code subscribes\n     * to this observable twice, it will subscribe twice to Stomp broker. (This was happening in the current example).\n     * A long but good explanatory article at https://medium.com/@benlesh/hot-vs-cold-observables-f8094ed53339\n     */\n    return coldObservable.share();\n  }\n/**\n * Callback Functions\n * \n * Note the method signature: () => preserves lexical scope\n * if we need to use this.x inside the function\n */\nprotected debug = (args: any): void => {\n      console.log(new Date(), args);\n  }\n/**\n * Callback run on successfully connecting to server\n */\nprotected on_connect = () => {\n\n    this.debug('Connected');\n\n    // Indicate our connected state to observers\n    this.state.next(StompState.CONNECTED);\n  }\n/**\n * Handle errors from stomp.js\n */\nprotected on_error = (error: string | Stomp.Message) => {\n\n    // Trigger the error subject\n    this.errorSubject.next(error);\n\n    if (typeof error === 'object') {\n      error = (<Stomp.Message>error).body;\n    }\n\n    this.debug(`Error: ${error}`);\n\n    // Check for dropped connection and try reconnecting\n    if (!this.client.connected) {\n      // Reset state indicator\n      this.state.next(StompState.CLOSED);\n    }\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n];\n}\n\nfunction StompRService_tsickle_Closure_declarations() {\n/** @type {?} */\nStompRService.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nStompRService.ctorParameters;\n/**\n * State of the STOMPService\n * \n * It is a BehaviorSubject and will emit current status immediately. This will typically get\n * used to show current status to the end user.\n * @type {?}\n */\nStompRService.prototype.state;\n/**\n * Will trigger when connection is established. Use this to carry out initialization.\n * It will trigger every time a (re)connection occurs. If it is already connected\n * it will trigger immediately. You can safely ignore the value, as it will always be\n * StompState.CONNECTED\n * @type {?}\n */\nStompRService.prototype.connectObservable;\n/**\n * Will trigger when an error occurs. This Subject can be used to handle errors from\n * the stomp broker.\n * @type {?}\n */\nStompRService.prototype.errorSubject;\n/**\n * Internal array to hold locally queued messages when STOMP broker is not connected.\n * @type {?}\n */\nStompRService.prototype.queuedMessages;\n/**\n * Configuration\n * @type {?}\n */\nStompRService.prototype._config;\n/**\n * STOMP Client from \\@stomp/stomp.js\n * @type {?}\n */\nStompRService.prototype.client;\n/**\n * Callback Functions\n * \n * Note the method signature: () => preserves lexical scope\n * if we need to use this.x inside the function\n * @type {?}\n */\nStompRService.prototype.debug;\n/**\n * Callback run on successfully connecting to server\n * @type {?}\n */\nStompRService.prototype.on_connect;\n/**\n * Handle errors from stomp.js\n * @type {?}\n */\nStompRService.prototype.on_error;\n}\n\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","import { StompHeaders } from './stomp-headers';\nimport { Injectable } from '@angular/core';\n/**\n * Represents a configuration object for the\n * STOMPService to connect to.\n */\nexport class StompConfig {\n/**\n * Server URL to connect to. Please refer to your STOMP broker documentation for details.\n * \n * Example: ws://127.0.0.1:15674/ws (for a RabbitMQ default setup running on localhost)\n * \n * Alternatively this parameter can be a function that returns an object similar to WebSocket\n * (typically SockJS instance).\n * \n * Example:\n * \n * () => {\n *   return new SockJS('http://127.0.0.1:15674/stomp');\n * }\n */\nurl: string | (() => any);\n/**\n * Headers\n * Typical keys: login: string, passcode: string.\n * host:string will neeed to be passed for virtual hosts in RabbitMQ\n */\nheaders: StompHeaders;\n/**\n * How often to incoming heartbeat?\n * Interval in milliseconds, set to 0 to disable\n * \n * Typical value 0 - disabled\n */\nheartbeat_in: number;\n/**\n * How often to outgoing heartbeat?\n * Interval in milliseconds, set to 0 to disable\n * \n * Typical value 20000 - every 20 seconds\n */\nheartbeat_out: number;\n/**\n * Wait in milliseconds before attempting auto reconnect\n * Set to 0 to disable\n * \n * Typical value 5000 (5 seconds)\n */\nreconnect_delay: number;\n/**\n * Enable client debugging?\n */\ndebug: boolean;\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n];\n}\n\nfunction StompConfig_tsickle_Closure_declarations() {\n/** @type {?} */\nStompConfig.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nStompConfig.ctorParameters;\n/**\n * Server URL to connect to. Please refer to your STOMP broker documentation for details.\n * \n * Example: ws://127.0.0.1:15674/ws (for a RabbitMQ default setup running on localhost)\n * \n * Alternatively this parameter can be a function that returns an object similar to WebSocket\n * (typically SockJS instance).\n * \n * Example:\n * \n * () => {\n *   return new SockJS('http://127.0.0.1:15674/stomp');\n * }\n * @type {?}\n */\nStompConfig.prototype.url;\n/**\n * Headers\n * Typical keys: login: string, passcode: string.\n * host:string will neeed to be passed for virtual hosts in RabbitMQ\n * @type {?}\n */\nStompConfig.prototype.headers;\n/**\n * How often to incoming heartbeat?\n * Interval in milliseconds, set to 0 to disable\n * \n * Typical value 0 - disabled\n * @type {?}\n */\nStompConfig.prototype.heartbeat_in;\n/**\n * How often to outgoing heartbeat?\n * Interval in milliseconds, set to 0 to disable\n * \n * Typical value 20000 - every 20 seconds\n * @type {?}\n */\nStompConfig.prototype.heartbeat_out;\n/**\n * Wait in milliseconds before attempting auto reconnect\n * Set to 0 to disable\n * \n * Typical value 5000 (5 seconds)\n * @type {?}\n */\nStompConfig.prototype.reconnect_delay;\n/**\n * Enable client debugging?\n * @type {?}\n */\nStompConfig.prototype.debug;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","import { Injectable } from '@angular/core';\n\nimport { StompConfig } from './stomp.config';\n\nimport { StompRService } from './stomp-r.service';\n/**\n * Angular2 STOMP Service using \\@stomp/stomp.js\n * \n * \\@description This service handles subscribing to a\n * message queue using the stomp.js library, and returns\n * values via the ES6 Observable specification for\n * asynchronous value streaming by wiring the STOMP\n * messages into an observable.\n * \n * If you want to manually configure and initialize the service\n * please use StompRService\n */\nexport class StompService extends StompRService {\n/**\n * Constructor\n * \n * See README and samples for configuration examples\n * @param {?} config\n */\npublic constructor(config: StompConfig) {\n    super();\n\n    this.config = config;\n    this.initAndConnect();\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: StompConfig, },\n];\n}\n\nfunction StompService_tsickle_Closure_declarations() {\n/** @type {?} */\nStompService.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nStompService.ctorParameters;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"],"names":["StompState","CLOSED","TRYING","CONNECTED","DISCONNECTING","StompRService","_this","this","queuedMessages","debug","args","console","log","Date","on_connect","state","next","on_error","error","errorSubject","body","client","connected","BehaviorSubject","connectObservable","filter","currentState","subscribe","sendQueuedMessages","Subject","Object","defineProperty","prototype","set","value","_config","initStompClient","disconnect","Stomp.client","url","Stomp.over","heartbeat","incoming","heartbeat_in","outgoing","heartbeat_out","reconnect_delay","initAndConnect","headers","connect","getValue","publish","queueName","message","send","push","_i","queuedMessages_1","length","queuedMessage","Observable","create","messages","stompSubscription","stompConnectedSubscription","unsubscribe","share","decorators","type","Injectable","ctorParameters","StompConfig","StompService","_super","config","call","__extends"],"mappings":"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"}
